% Generated by Sphinx.
\def\sphinxdocclass{report}
\documentclass[letterpaper,10pt,english]{sphinxmanual}
\usepackage[utf8]{inputenc}
\DeclareUnicodeCharacter{00A0}{\nobreakspace}
\usepackage[T1]{fontenc}
\usepackage{babel}
\usepackage{times}
\usepackage[Bjarne]{fncychap}
\usepackage{longtable}
\usepackage{sphinx}
\usepackage{multirow}


\title{SFFT Documentation}
\date{June 11, 2013}
\release{0.1}
\author{Jörn Schumacher}
\newcommand{\sphinxlogo}{}
\renewcommand{\releasename}{Release}
\makeindex

\makeatletter
\def\PYG@reset{\let\PYG@it=\relax \let\PYG@bf=\relax%
    \let\PYG@ul=\relax \let\PYG@tc=\relax%
    \let\PYG@bc=\relax \let\PYG@ff=\relax}
\def\PYG@tok#1{\csname PYG@tok@#1\endcsname}
\def\PYG@toks#1+{\ifx\relax#1\empty\else%
    \PYG@tok{#1}\expandafter\PYG@toks\fi}
\def\PYG@do#1{\PYG@bc{\PYG@tc{\PYG@ul{%
    \PYG@it{\PYG@bf{\PYG@ff{#1}}}}}}}
\def\PYG#1#2{\PYG@reset\PYG@toks#1+\relax+\PYG@do{#2}}

\def\PYG@tok@gd{\def\PYG@tc##1{\textcolor[rgb]{0.63,0.00,0.00}{##1}}}
\def\PYG@tok@gu{\let\PYG@bf=\textbf\def\PYG@tc##1{\textcolor[rgb]{0.50,0.00,0.50}{##1}}}
\def\PYG@tok@gt{\def\PYG@tc##1{\textcolor[rgb]{0.00,0.25,0.82}{##1}}}
\def\PYG@tok@gs{\let\PYG@bf=\textbf}
\def\PYG@tok@gr{\def\PYG@tc##1{\textcolor[rgb]{1.00,0.00,0.00}{##1}}}
\def\PYG@tok@cm{\let\PYG@it=\textit\def\PYG@tc##1{\textcolor[rgb]{0.25,0.50,0.56}{##1}}}
\def\PYG@tok@vg{\def\PYG@tc##1{\textcolor[rgb]{0.73,0.38,0.84}{##1}}}
\def\PYG@tok@m{\def\PYG@tc##1{\textcolor[rgb]{0.13,0.50,0.31}{##1}}}
\def\PYG@tok@mh{\def\PYG@tc##1{\textcolor[rgb]{0.13,0.50,0.31}{##1}}}
\def\PYG@tok@cs{\def\PYG@tc##1{\textcolor[rgb]{0.25,0.50,0.56}{##1}}\def\PYG@bc##1{\colorbox[rgb]{1.00,0.94,0.94}{##1}}}
\def\PYG@tok@ge{\let\PYG@it=\textit}
\def\PYG@tok@vc{\def\PYG@tc##1{\textcolor[rgb]{0.73,0.38,0.84}{##1}}}
\def\PYG@tok@il{\def\PYG@tc##1{\textcolor[rgb]{0.13,0.50,0.31}{##1}}}
\def\PYG@tok@go{\def\PYG@tc##1{\textcolor[rgb]{0.19,0.19,0.19}{##1}}}
\def\PYG@tok@cp{\def\PYG@tc##1{\textcolor[rgb]{0.00,0.44,0.13}{##1}}}
\def\PYG@tok@gi{\def\PYG@tc##1{\textcolor[rgb]{0.00,0.63,0.00}{##1}}}
\def\PYG@tok@gh{\let\PYG@bf=\textbf\def\PYG@tc##1{\textcolor[rgb]{0.00,0.00,0.50}{##1}}}
\def\PYG@tok@ni{\let\PYG@bf=\textbf\def\PYG@tc##1{\textcolor[rgb]{0.84,0.33,0.22}{##1}}}
\def\PYG@tok@nl{\let\PYG@bf=\textbf\def\PYG@tc##1{\textcolor[rgb]{0.00,0.13,0.44}{##1}}}
\def\PYG@tok@nn{\let\PYG@bf=\textbf\def\PYG@tc##1{\textcolor[rgb]{0.05,0.52,0.71}{##1}}}
\def\PYG@tok@no{\def\PYG@tc##1{\textcolor[rgb]{0.38,0.68,0.84}{##1}}}
\def\PYG@tok@na{\def\PYG@tc##1{\textcolor[rgb]{0.25,0.44,0.63}{##1}}}
\def\PYG@tok@nb{\def\PYG@tc##1{\textcolor[rgb]{0.00,0.44,0.13}{##1}}}
\def\PYG@tok@nc{\let\PYG@bf=\textbf\def\PYG@tc##1{\textcolor[rgb]{0.05,0.52,0.71}{##1}}}
\def\PYG@tok@nd{\let\PYG@bf=\textbf\def\PYG@tc##1{\textcolor[rgb]{0.33,0.33,0.33}{##1}}}
\def\PYG@tok@ne{\def\PYG@tc##1{\textcolor[rgb]{0.00,0.44,0.13}{##1}}}
\def\PYG@tok@nf{\def\PYG@tc##1{\textcolor[rgb]{0.02,0.16,0.49}{##1}}}
\def\PYG@tok@si{\let\PYG@it=\textit\def\PYG@tc##1{\textcolor[rgb]{0.44,0.63,0.82}{##1}}}
\def\PYG@tok@s2{\def\PYG@tc##1{\textcolor[rgb]{0.25,0.44,0.63}{##1}}}
\def\PYG@tok@vi{\def\PYG@tc##1{\textcolor[rgb]{0.73,0.38,0.84}{##1}}}
\def\PYG@tok@nt{\let\PYG@bf=\textbf\def\PYG@tc##1{\textcolor[rgb]{0.02,0.16,0.45}{##1}}}
\def\PYG@tok@nv{\def\PYG@tc##1{\textcolor[rgb]{0.73,0.38,0.84}{##1}}}
\def\PYG@tok@s1{\def\PYG@tc##1{\textcolor[rgb]{0.25,0.44,0.63}{##1}}}
\def\PYG@tok@gp{\let\PYG@bf=\textbf\def\PYG@tc##1{\textcolor[rgb]{0.78,0.36,0.04}{##1}}}
\def\PYG@tok@sh{\def\PYG@tc##1{\textcolor[rgb]{0.25,0.44,0.63}{##1}}}
\def\PYG@tok@ow{\let\PYG@bf=\textbf\def\PYG@tc##1{\textcolor[rgb]{0.00,0.44,0.13}{##1}}}
\def\PYG@tok@sx{\def\PYG@tc##1{\textcolor[rgb]{0.78,0.36,0.04}{##1}}}
\def\PYG@tok@bp{\def\PYG@tc##1{\textcolor[rgb]{0.00,0.44,0.13}{##1}}}
\def\PYG@tok@c1{\let\PYG@it=\textit\def\PYG@tc##1{\textcolor[rgb]{0.25,0.50,0.56}{##1}}}
\def\PYG@tok@kc{\let\PYG@bf=\textbf\def\PYG@tc##1{\textcolor[rgb]{0.00,0.44,0.13}{##1}}}
\def\PYG@tok@c{\let\PYG@it=\textit\def\PYG@tc##1{\textcolor[rgb]{0.25,0.50,0.56}{##1}}}
\def\PYG@tok@mf{\def\PYG@tc##1{\textcolor[rgb]{0.13,0.50,0.31}{##1}}}
\def\PYG@tok@err{\def\PYG@bc##1{\fcolorbox[rgb]{1.00,0.00,0.00}{1,1,1}{##1}}}
\def\PYG@tok@kd{\let\PYG@bf=\textbf\def\PYG@tc##1{\textcolor[rgb]{0.00,0.44,0.13}{##1}}}
\def\PYG@tok@ss{\def\PYG@tc##1{\textcolor[rgb]{0.32,0.47,0.09}{##1}}}
\def\PYG@tok@sr{\def\PYG@tc##1{\textcolor[rgb]{0.14,0.33,0.53}{##1}}}
\def\PYG@tok@mo{\def\PYG@tc##1{\textcolor[rgb]{0.13,0.50,0.31}{##1}}}
\def\PYG@tok@mi{\def\PYG@tc##1{\textcolor[rgb]{0.13,0.50,0.31}{##1}}}
\def\PYG@tok@kn{\let\PYG@bf=\textbf\def\PYG@tc##1{\textcolor[rgb]{0.00,0.44,0.13}{##1}}}
\def\PYG@tok@o{\def\PYG@tc##1{\textcolor[rgb]{0.40,0.40,0.40}{##1}}}
\def\PYG@tok@kr{\let\PYG@bf=\textbf\def\PYG@tc##1{\textcolor[rgb]{0.00,0.44,0.13}{##1}}}
\def\PYG@tok@s{\def\PYG@tc##1{\textcolor[rgb]{0.25,0.44,0.63}{##1}}}
\def\PYG@tok@kp{\def\PYG@tc##1{\textcolor[rgb]{0.00,0.44,0.13}{##1}}}
\def\PYG@tok@w{\def\PYG@tc##1{\textcolor[rgb]{0.73,0.73,0.73}{##1}}}
\def\PYG@tok@kt{\def\PYG@tc##1{\textcolor[rgb]{0.56,0.13,0.00}{##1}}}
\def\PYG@tok@sc{\def\PYG@tc##1{\textcolor[rgb]{0.25,0.44,0.63}{##1}}}
\def\PYG@tok@sb{\def\PYG@tc##1{\textcolor[rgb]{0.25,0.44,0.63}{##1}}}
\def\PYG@tok@k{\let\PYG@bf=\textbf\def\PYG@tc##1{\textcolor[rgb]{0.00,0.44,0.13}{##1}}}
\def\PYG@tok@se{\let\PYG@bf=\textbf\def\PYG@tc##1{\textcolor[rgb]{0.25,0.44,0.63}{##1}}}
\def\PYG@tok@sd{\let\PYG@it=\textit\def\PYG@tc##1{\textcolor[rgb]{0.25,0.44,0.63}{##1}}}

\def\PYGZbs{\char`\\}
\def\PYGZus{\char`\_}
\def\PYGZob{\char`\{}
\def\PYGZcb{\char`\}}
\def\PYGZca{\char`\^}
\def\PYGZsh{\char`\#}
\def\PYGZpc{\char`\%}
\def\PYGZdl{\char`\$}
\def\PYGZti{\char`\~}
% for compatibility with earlier versions
\def\PYGZat{@}
\def\PYGZlb{[}
\def\PYGZrb{]}
\makeatother

\begin{document}

\maketitle
\tableofcontents
\phantomsection\label{index::doc}


Contents:


\chapter{Introduction}
\label{introduction:introduction}\label{introduction::doc}\label{introduction:welcome-to-the-sfft-library-s-documentation}
The \emph{Sparse Fast Fourier Transform} is a DFT algorithm specifically designed
for signals with a sparse frequency domain. This library is a high-performance
C++ implementation of versions 1, 2, and 3 of the different SFFT variants.


\section{When Should I use the SFFT library?}
\label{introduction:when-should-i-use-the-sfft-library}
You should use the SFFT library when you want to compute the \href{http://en.wikipedia.org/wiki/Discrete\_Fourier\_transform}{Discrete Fourier
Transform} of a signal and only a few frequency components
occur in the signal. Your signal may be noisy or not, but currently there are
some limitations for noisy signals (see {\hyperref[introduction:current-state]{\emph{Limitations and Known Bugs}}}).


\section{Target Platform}
\label{introduction:target-platform}\label{introduction:discrete-fourier-transform}
The SFFT library was optimized to run on modern x86 desktop CPUs with SSE
support. Optionally the implementation can use the Intel IPP library, which is
only available on Intel platforms.


\section{Limitations and Known Bugs}
\label{introduction:current-state}\label{introduction:limitations-and-known-bugs}
The SFFT library features implementations of SFFT v1, v2, and v3. SFFT v1 and
v2 currently only work with a few specific input parameters. SFFT v3 cannot
handle signals with noise.

There are no known bugs so far.


\section{Disclaimer}
\label{introduction:disclaimer}
The current SFFT implementation is in an experimental state. It is NOT
intended to be used as a drop-in replacement for the FFT library of your choice.
Be prepared to find bugs. There is absolutely NO WARRANTY for the correct
functioning of this software.


\section{Credits}
\label{introduction:credits}
The original SFFT sourcecode was developed by Haitham Hassanieh, Piotr Indyk,
Dina Katabi, and Eric Price at the Computer Science and Artifical Intelligence
Lab at MIT. The original sourcecode and contact information can be found at
their website \href{http://groups.csail.mit.edu/netmit/sFFT/}{Sparse Fast Fourier Transform Website}.

Performance optimizations were developed by Jörn Schumacher
as part of his \href{http://www.spiral.net/software/sfft.html}{Master Thesis Project} at the
Computer Science Department of ETH Zurich in 2013, under the supervision of
Prof. \href{http://www.inf.ethz.ch/personal/markusp/}{Markus Püschel}.


\section{Contact Information}
\label{introduction:contact-information}
If you are interested in the theory behind the Sparse Fast Fourier Transform,
contact the inventors of the SFFT, Haitham Hassanieh, Piotr Indyk, Dina Katabi,
and Eric Price, at their \href{http://groups.csail.mit.edu/netmit/sFFT/}{Sparse Fast Fourier Transform Website}.

If you are interested in performance optimizations that were applied, contact
Jörn Schumacher at \href{mailto:joerns@student.ethz.ch}{joerns@student.ethz.ch}.


\chapter{Installation}
\label{installation::doc}\label{installation:markus-puschel}\label{installation:installation}

\section{Prerequisites}
\label{installation:prerequisites}
The SFFT library was only tested on Linux systems and is only guaranteed to
work there. However, the library should also be able to compile on other
platforms and operating systems.

The following packages have to be installed to compile the library:
\begin{itemize}
\item {} 
Python (any version \textgreater{} 2.3, including Python 3), used by the \href{https://code.google.com/p/waf/}{waf} build
system

\item {} 
\href{http://www.fftw.org/}{FFTW} 3

\item {} 
\emph{(optionally)} \href{http://software.intel.com/intel-ipp}{Intel Integrated Performance Primitives}

\end{itemize}

If you want to build benchmark tools, also install
\begin{itemize}
\item {} 
\href{http://valgrind.org/}{Valgrind}

\end{itemize}

The SFFT library is known to work the following compilers:
\begin{itemize}
\item {} 
\href{http://gcc.gnu.org/}{GCC} (tested with GCC 4.4 and 4.7)

\item {} 
\href{http://software.intel.com/en-us/intel-compilers}{Intel C++ Compiler}  (only versions \textgreater{}= 13, does NOT work with ICC 12)

\end{itemize}


\section{Compiling From Source and Installation}
\label{installation:intel-c-compiler}\label{installation:compiling-from-source-and-installation}
Unpack the tarball and change into the newly created directory
(sfft-\emph{version}). Then, the SFFT library can be built with a simple:

\begin{Verbatim}[commandchars=\\\{\}]
\$ ./configure
\$ make
\end{Verbatim}

and installed with:

\begin{Verbatim}[commandchars=\\\{\}]
\$ make install
\end{Verbatim}

Some configuration options can be passed to the configuration script. The most
important are:

\begin{Verbatim}[commandchars=\\\{\}]
\$ ./configure --help

[...]
--debug               compile in debug mode
--profile             add source-level profiling to instruction counting programs
--without-ipp         do not the Intel Performance Primitives library
[...]
\end{Verbatim}

Use \code{-{-}debug} and \code{-{-}profile} are only useful when developing (see
{\hyperref[development:development]{\emph{Development}}}). The option \code{-{-}without-ipp} is to be used when you do not have
Intel IPP installed.

When these steps succeded, you should be ready to use the SFFT library.


\section{Linking against the SFFT Library}
\label{installation:linking-against-the-sfft-library}
Two versions of the SFFT library are built when compiling the sourcecode:
a static library (libsfft.a) and a shared library (libsfft.so). You can link
these libraries in your programs like any other library, but you have to make
sure that you link dependencies as well.

Do not forget to link:
\begin{itemize}
\item {} 
FFTW, for example via \emph{pkg-config}: \code{pkg-config -{-}cflags -{-}libs fftw3}

\item {} 
Intel IPP (if not disabled via \code{-{-}without-ipp}),
e.g. \code{-lippvm -lipps -pthread}

\item {} 
Your compilers OpenMP library, for example \code{-lgomp} for GCC

\item {} 
\emph{libm} and \emph{librt} (\code{-lm -lrt})

\end{itemize}


\chapter{Usage}
\label{usage:usage}\label{usage::doc}
All types and functions of the SFFT library are defined in the header
\code{sfft.h}. Include it at the beginning of your program.


\section{Computing Sparse DFTs}
\label{usage:computing-sparse-dfts}

\subsection{Creating Plans}
\label{usage:creating-plans}
SFFT executions consist of two seperate steps: planning and execution. The
planning phase is only executed once for specific input parameters. After
that, many Sparse DFTs with these input parameters can be computed (on
different input vectors). This concept is similar to FFTW's concept of plans.

You can create a plan with a call to \code{sfft\_plan}:

\begin{Verbatim}[commandchars=\\\{\}]
sfft\_plan* sfft\_make\_plan(int n, int k, sfft\_version version,
                          int fftw\_optimization);
\end{Verbatim}

The call returns a pointer to a struct of type \code{sfft\_plan}, which has to be
manually freed with \code{sfft\_free\_plan}. Parameters of \code{sfft\_make\_plan} are:
\begin{description}
\item[{\code{n}}] \leavevmode
The size of the input vector.

\item[{\code{k}}] \leavevmode
The number of frequencies in the signal, i.e. the signal's \emph{sparsity}.

\item[{\code{version}}] \leavevmode
The SFFT algorithm version to use. Either \code{SFFT\_VERSION\_1},
\code{SFFT\_VERSION\_2}, or \code{SFFT\_VERSION\_3}.

\item[{\code{fftw\_optimization}}] \leavevmode
FFTW optimization level. Usually one of \code{FFTW\_MEASURE} and
\code{FFTW\_ESTIMATE}. Since experiments showed that there is little benefit
in using the more expensive \code{FFTW\_MEASURE}, the best choice is typically
\code{FFTW\_ESTIMATE}.

\end{description}


\subsection{Creating Input Vectors}
\label{usage:creating-input-vectors}
The storage for SFFT input vectors has to allocated using \code{sfft\_malloc}:

\begin{Verbatim}[commandchars=\\\{\}]
void* sfft\_malloc(size\_t s);
\end{Verbatim}

The reason for this is that the implementation requires a specific memory
alignment on the input vectors. You can use \code{sfft\_malloc} as a drop-in
replacement for \code{malloc}.

Input vectors should be of type \code{complex\_t}, which is a typedef to the C
standard library's type \code{double complex}.

Storage allocated with \code{sfft\_malloc} must be freed with this function:

\begin{Verbatim}[commandchars=\\\{\}]
void sfft\_free(void*);
\end{Verbatim}


\subsection{Creating the Output Datastructure}
\label{usage:creating-the-output-datastructure}
The output of the SFFT is stored in an associative array that maps frequency
coordinates to coefficients.  The array should be of type \code{sfft\_output},
which is a typedef to an \code{std::unordered\_map}. Before executing the SFFT
plans, you need to create the output datastructure. A pointer to it is passed
to the SFFT execution call and the datastructure filled with the result.


\subsection{Computing a Single Sparse DFT}
\label{usage:computing-a-single-sparse-dft}
Once a plan is created, input vectors are created filled with data, and an
output object was allocated, the SFFT plans can be executed. The function for
this is:

\begin{Verbatim}[commandchars=\\\{\}]
void sfft\_exec(sfft\_plan* plan, complex\_t* in, sfft\_output* out);
\end{Verbatim}

Parameters should be self-explanatory. After execution of this function, the
output of the DFT is stored in \code{*out}.


\subsection{Computing Multiple Sparse DFTs}
\label{usage:computing-multiple-sparse-dfts}
If you want to run multiple SFFT calls on different inputs (but with the same
input sizes), you can use \code{sfft\_exec\_many} to run the calls in parallel:

\begin{Verbatim}[commandchars=\\\{\}]
void sfft\_exec\_many(sfft\_plan* plan,
                    int num, complex\_t** in, sfft\_output* out);
\end{Verbatim}

The function is very similar to \code{sfft\_exec}, but you can pass it put \code{num}
input-vectors and \code{num} output-objects. The SFFT library used OpenMP for
parallelization; thus, you can use either the environment variable
\code{OMP\_NUM\_THREADS} or OpenMP library functions to adjust the number of
threads. Be careful: do \emph{not} use different thread number configuration for
the  call to \code{sfft\_make\_plan} and \code{sfft\_exec\_many}. Otherwise your
program will crash!


\section{SFFT Versions}
\label{usage:sfft-versions}
Currently, three different SFFT versions are implemented: SFFT v1, v2, and v3.

SFFT v3 is the algorithm of choice when your input signals are exactly-sparse;
that is, there is no additional noise in the signals. SFFT v3 will not work
with noisy signals.

SFFT v1 and v2 can also be applied to noisy signals, but they only work with
certain input parameter combinations. Valid input parameters combinations:

\begin{tabulary}{\linewidth}{|L|L|}
\hline
\textbf{
Signal Size
} & \textbf{
Sparsity
}\\\hline

8192
 & 
50
\\\hline

16384
 & 
50
\\\hline

32768
 & 
50
\\\hline

65536
 & 
50
\\\hline

131072
 & 
50
\\\hline

262144
 & 
50
\\\hline

524288
 & 
50
\\\hline

1048576
 & 
50
\\\hline

2097152
 & 
50
\\\hline

4194304
 & 
50
\\\hline

8388608
 & 
50
\\\hline

16777216
 & 
50
\\\hline

4194304
 & 
50
\\\hline

4194304
 & 
100
\\\hline

4194304
 & 
200
\\\hline

4194304
 & 
500
\\\hline

4194304
 & 
1000
\\\hline

4194304
 & 
2000
\\\hline

4194304
 & 
2500
\\\hline

4194304
 & 
4000
\\\hline
\end{tabulary}



\chapter{Development}
\label{development:development}\label{development::doc}\label{development:id1}

\section{Development and Benchmark Tools}
\label{development:development-and-benchmark-tools}
The SFFT library includes some useful tools for development and benchmarking.
To enable them, you have to configure with the \code{-{-}develop} flag. Then, the
following programs will be built additionally:
\begin{description}
\item[{\code{sfft-cachemisses}}] \leavevmode
Runs an SFFT on random input. The tool is handy when used with Valgrind's
cachegrind tool. The program includes some instructions to disable
valgrind during the input-generation and planning phases. Thus, when the
program is analyzed with cachegrind, only the execution phase will be
observed.

\item[{\code{sfft-instruction\_count}}] \leavevmode
Counts the floating point instructions of the specified SFFT call
(configured with program parameters, see below) and prints them. When the
configuration option \code{-{-}profile} was defined, this will also print a
profile of the SFFT call.

\item[{\code{sfft-profiling}}] \leavevmode
Another program that runs a configurable SFFT call. This program will be
compiled with the profiling flags \code{-pg}, so that it can be analyzed with
the \code{gprof} profiling tool.

\item[{\code{sfft-timing}}] \leavevmode
A program that accurately measures the runtime of the specified SFFT call.
This can be used by benchmark scripts.

\item[{\code{sfft-timing\_many}}] \leavevmode
Similar to \code{sfft-timing}, but measures the parallel execution of
multiple SFFT calls.

\item[{\code{sfft-verification}}] \leavevmode
This program runs the specified SFFT call and checks that the output is
correct. This is useful for testing.

\end{description}

All of the programs run one or many SFFT executions. Random input data is
generated automatically. The programs share the following common options:
\begin{description}
\item[{\code{-n SIZE}}] \leavevmode
The size of the input signal.

\item[{\code{-k NUMBER}}] \leavevmode
Number of frequencies generated in the random input signal.

\item[{\code{-r REPETITIONS}}] \leavevmode
\emph{NOT available for sfft-timing\_many.} Allows to compute multiple SFFTs.
Default: 1. .

\item[{\code{-i NUM}}] \leavevmode
\emph{Only available for sfft-timing\_many.} Generate NUM inputs.

\item[{\code{-s}}] \leavevmode
\emph{Only available for sfft-timing\_many.} Do not share data between
threads. This is slower.

\item[{\code{-v VERSION}}] \leavevmode
Selects the algorithm version to use. \code{VERSION} is either 1, 2, or 3. {}`{}`

\item[{\code{-o}}] \leavevmode
When \code{-o} is used, \code{FFTW\_MEASURE} is used for FFTW calls instead of
\code{FFTW\_ESTIMATE}.

\item[{\code{-h}}] \leavevmode
Displays help.

\end{description}


\section{An Overview of the Sourcecode}
\label{development:an-overview-of-the-sourcecode}
Here is an overview of the purpose of different sourcefiles:
\begin{description}
\item[{\emph{cachemisses.cc, timing.cc, timing\_many.cc, instruction\_count.cc, verification.cc, simulation.{[}cc,h{]}}}] \leavevmode
The \code{main} routines and some support code for all development tools
are located in these files.

\item[{\emph{computefourier-1.0-2.0.{[}cc,h{]}}}] \leavevmode
Algorithm sourcecode for SFFT v1 and v2.

\item[{\emph{computefourier-3.0.{[}cc,h{]}}}] \leavevmode
Algorithm sourcecode for SFFT v3.

\item[{\emph{fft.h, common.{[}cc,h{]}, utils.{[}cc,h{]}}}] \leavevmode
Some common code and datatypes.

\item[{\emph{fftw.{[}cc,h{]}}}] \leavevmode
Interface code for FFTW calls.

\item[{\emph{filters.{[}cc,h{]}}}] \leavevmode
The routines to generate filter vectors are in here.

\item[{\emph{intrinsics.h}}] \leavevmode
Some compiler-specific abstractions to include the correct intrinsics
header.

\item[{\emph{parameters.{[}cc,h{]}}}] \leavevmode
Parameter configuration for SFFT v1, v2.

\item[{\emph{profiling\_tools.h}}] \leavevmode
Some preprocessor tools to allow profiling, used when compiled with
\code{-{-}profile}.

\item[{\emph{roofline.cc}}] \leavevmode
A program to use with the roofline tool \emph{perfplot}. Can be built with
\code{tools/build-roofline.sh}.

\item[{\emph{sfft.{[}cc,h{]}}}] \leavevmode
User interface code and basic datastructures. The headerfile is to be
included by users.

\item[{\emph{timer.{[}cc,h{]}}}] \leavevmode
Functions for accurate timing, used by \code{sfft-timing}.

\item[{\emph{flopcount/}}] \leavevmode
Files in this directory are used to count floating point operations, used
by \code{sfft-instruction\_count}.

\end{description}


\chapter{Indices and tables}
\label{index:indices-and-tables}\begin{itemize}
\item {} 
\emph{genindex}

\item {} 
\emph{modindex}

\item {} 
\emph{search}

\end{itemize}



\renewcommand{\indexname}{Index}
\printindex
\end{document}
